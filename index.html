<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jump Sort Simulation</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #f9f9f9;
    }
    h1 {
      text-align: center;
    }
    .metadata {
      background: #e0ffe0;
      padding: 10px;
      border-left: 5px solid green;
      margin: 20px 0;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 50px;
      margin-top: 40px;
    }
    .button {
      background-color: #5c6bc0;
      color: white;
      font-size: 24px;
      border: none;
      border-radius: 10px;
      padding: 20px 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: background-color 0.3s ease;
    }
    .button:hover {
      background-color: #3f51b5;
    }
    .hidden {
      display: none;
    }
    .visualizer {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      height: 300px;
      margin-top: 40px;
      background: #f2edf0;
      transition: all 0.3s ease;
    }
    .bar {
      background: #aaa;
      width: 30px;
      margin: 0 3px;
      text-align: center;
      color: black;
      font-size: 14px;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
      transition: height 0.4s ease, background 0.4s ease;
    }
    .bar span {
      margin-top: 4px;
    }
    .step-label {
      text-align: center;
      font-size: 18px;
      margin-top: 20px;
      font-weight: bold;
    }
    .implementations {
      margin-top: 80px;
      background: #1e1e1e;
      padding: 20px;
      border-radius: 8px;
      color: white;
    }
    .tabs {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .tab {
      cursor: pointer;
      background: #333;
      padding: 10px 20px;
      border-radius: 5px;
      transition: background 0.3s;
    }
    .tab:hover, .tab.active {
      background: #555;
    }
    .code-block {
      background: #2b2b2b;
      padding: 15px;
      border-radius: 5px;
      white-space: pre;
      overflow-x: auto;
      font-family: monospace;
      display: none;
    }
    .code-block.active {
      display: block;
    }
  </style>
</head>
<body>
  <h1>Jump Sort Visualization</h1>

  <div class="metadata">
    <p><strong>Time Complexity:</strong> O(n + k)</p>
    <p><strong>Space Complexity:</strong> O(n + k)</p>
    <p><strong>No comparisons used.</strong> Just direct jumps into indexed buckets.</p>
  </div>

  <div class="controls" id="startControls">
    <button class="button" onclick="startSimulation()">
      ▶️ Start
    </button>
  </div>

  <div class="controls hidden" id="stepControls">
    <button class="button" onclick="prevStep()">
      ◀️
    </button>
    <button class="button" onclick="nextStep()">
      ▶️
    </button>
  </div>

  <div class="step-label" id="stepLabel"></div>
  <div class="visualizer" id="visualizer"></div>

  <div class="implementations">
    <h2 style="text-align:center">IMPLEMENTATIONS</h2>
    <div class="tabs">
      <div class="tab active" onclick="showCode('java')">Java</div>
      <div class="tab" onclick="showCode('python')">Python</div>
    </div>
    <div id="java" class="code-block active">
      public class jumpsort {
        public int[] sortArray(int[] nums) {
            int n = nums.length;
    
            // Separate into negatives and non-negatives
            int[] negatives = new int[n];
            int[] nonNegatives = new int[n];
            int negCount = 0, posCount = 0;
    
            for (int num : nums) {
                if (num < 0) {
                    negatives[negCount++] = num;
                } else {
                    nonNegatives[posCount++] = num;
                }
            }
    
            // Handle negatives (bucketed using abs)
            int maxAbsNeg = 0;
            for (int i = 0; i < negCount; i++) {
                int absVal = Math.abs(negatives[i]);
                if (absVal > maxAbsNeg) {
                    maxAbsNeg = absVal;
                }
            }
    
            int[][] negBuckets = new int[maxAbsNeg][];
            int[] negBucketCounts = new int[maxAbsNeg];
            for (int i = 0; i < negCount; i++) {
                int index = Math.abs(negatives[i]) - 1;
                negBucketCounts[index]++;
            }
    
            for (int i = 0; i < maxAbsNeg; i++) {
                negBuckets[i] = new int[negBucketCounts[i]];
                negBucketCounts[i] = 0;
            }
    
            for (int i = 0; i < negCount; i++) {
                int index = Math.abs(negatives[i]) - 1;
                negBuckets[index][negBucketCounts[index]++] = negatives[i];
            }
    
            // Flatten reversed negatives
            int[] sortedNegatives = new int[negCount];
            int indexNeg = 0;
            for (int i = maxAbsNeg - 1; i >= 0; i--) {
                for (int val : negBuckets[i]) {
                    sortedNegatives[indexNeg++] = val;
                }
            }
    
            // Handle non-negatives (bucketed by value)
            int maxPos = 0;
            for (int i = 0; i < posCount; i++) {
                if (nonNegatives[i] > maxPos) {
                    maxPos = nonNegatives[i];
                }
            }
    
            int[][] posBuckets = new int[maxPos + 1][];
            int[] posBucketCounts = new int[maxPos + 1];
            for (int i = 0; i < posCount; i++) {
                posBucketCounts[nonNegatives[i]]++;
            }
    
            for (int i = 0; i <= maxPos; i++) {
                posBuckets[i] = new int[posBucketCounts[i]];
                posBucketCounts[i] = 0;
            }
    
            for (int i = 0; i < posCount; i++) {
                int val = nonNegatives[i];
                posBuckets[val][posBucketCounts[val]++] = val;
            }
    
            int[] result = new int[n];
            int index = 0;
    
            for (int i = 0; i < negCount; i++) {
                result[index++] = sortedNegatives[i];
            }
            for (int i = 0; i <= maxPos; i++) {
                for (int val : posBuckets[i]) {
                    result[index++] = val;
                }
            }
    
            return result;
        }
    }
  
    </div>
    <div id="python" class="code-block">
      class jumpsort(object):
      def sortArray(self, nums):
  
          # Separate negatives and non-negatives
          negatives = [x for x in nums if x < 0]
          non_negatives = [x for x in nums if x >= 0]
  
          # Prepare negative side using counts
          if negatives:
              max_neg = abs(min(negatives))
              neg_counts = [0] * max_neg
              for num in negatives:
                  index = abs(num) - 1
                  neg_counts[index] += 1
              neg_list = []
              for i in reversed(range(max_neg)):
                  neg_list.extend([-i - 1] * neg_counts[i])
          else:
              neg_list = []
  
          # Prepare non-negative side using counts
          if non_negatives:
              max_nonneg = max(non_negatives)
              pos_counts = [0] * (max_nonneg + 1)
              for num in non_negatives:
                  pos_counts[num] += 1
              pos_list = []
              for i in range(max_nonneg + 1):
                  pos_list.extend([i] * pos_counts[i])
          else:
              pos_list = []
  
          return neg_list + pos_list  
    </div>
  </div>

  <script>
    const unsorted = [24, -6, 35, -17, 9, -6, 16, 29, 47, -16];
    let currentStep = 0;

    const jumpSortSteps = (input) => {
      const negatives = [], nonNegatives = [];
      input.forEach(num => num < 0 ? negatives.push(num) : nonNegatives.push(num));

      const maxAbsNeg = Math.max(...negatives.map(n => Math.abs(n)), 0);
      const maxPos = Math.max(...nonNegatives, 0);

      const negList = Array(maxAbsNeg).fill(null);
      const posList = Array(maxPos + 1).fill(null);

      negatives.forEach(n => {
        const index = maxAbsNeg - Math.abs(n);
        negList[index] = n;
      });

      nonNegatives.forEach(n => {
        posList[n] = n;
      });

      return [
        input,
        [negatives, nonNegatives],
        [negList, posList],
        [...negList.filter(n => n !== null), ...posList.filter(n => n !== null)]
      ];
    };

    const stepTitles = [
      "Step 1: Original Unsorted Array",
      "Step 2: Split into Negatives and Non-Negatives",
      "Step 3: Place Values at Indexed Positions",
      "Step 4: Final Sorted Output"
    ];

    const steps = jumpSortSteps(unsorted);

    const startSimulation = () => {
      document.getElementById('startControls').classList.add('hidden');
      document.getElementById('stepControls').classList.remove('hidden');
      currentStep = 0;
      showStep();
    };

    const nextStep = () => {
      if (currentStep < steps.length - 1) currentStep++;
      showStep();
    };

    const prevStep = () => {
      if (currentStep > 0) currentStep--;
      showStep();
    };

    const showStep = () => {
      const visualizer = document.getElementById('visualizer');
      const stepLabel = document.getElementById('stepLabel');
      visualizer.innerHTML = '';
      stepLabel.textContent = stepTitles[currentStep];

      let bars = [];
      switch (currentStep) {
        case 0:
          bars = steps[0];
          break;
        case 1:
          bars = [...steps[1][0], ...steps[1][1]];
          break;
        case 2:
          bars = [...steps[2][0], ...steps[2][1]];
          break;
        case 3:
          bars = steps[3];
          break;
      }

      bars.forEach(value => {
        const bar = document.createElement('div');
        bar.className = 'bar';
        const val = value !== null ? value : 0;
        bar.style.height = `${Math.abs(val) * 5}px`;
        bar.innerHTML = value !== null ? `<span>${value}</span>` : "";
        bar.style.background = value == null ? '#eee' : value < 0 ? '#f77' : '#aaa';
        visualizer.appendChild(bar);
      });
    };

    function showCode(lang) {
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.code-block').forEach(block => block.classList.remove('active'));
      document.getElementById(lang).classList.add('active');
      event.target.classList.add('active');
    }
  </script>
<footer style="margin-top: 60px; text-align: center; font-size: 16px; color: #eee; background: #1e1e1e; padding: 20px; border-radius: 8px;">
  🚀 Made with care by Jaspreet Jawanda <br>
  🌐 <a href="https://www.jjawanda.me" target="_blank" style="color: #7abaff; text-decoration: none; font-weight: bold;">My Website</a> | 
  💼 <a href="https://www.linkedin.com/in/jaspreet-jawanda/" target="_blank" style="color: #7abaff; text-decoration: none; font-weight: bold;">LinkedIn</a>
<br><br>
  <a href="https://github.com/sayanwala117/JumpSort" target="_blank" style="display: inline-block; margin-top: 15px; background: #24292e; color: #ffffff; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-weight: bold;">
    ⭐ View this project on GitHub
  </a>
</footer>
</body>
</html>
